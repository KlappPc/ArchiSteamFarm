<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata" id="root">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace"/>
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0"/>
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string"/>
              <xsd:attribute name="type" type="xsd:string"/>
              <xsd:attribute name="mimetype" type="xsd:string"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string"/>
              <xsd:attribute name="name" type="xsd:string"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1"/>
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3"/>
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required"/>
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="CategoryAccess" xml:space="preserve">
    <value>접근</value>
  </data>
  <data name="CategoryAdvanced" xml:space="preserve">
    <value>고급</value>
  </data>
  <data name="CategoryCore" xml:space="preserve">
    <value>코어</value>
  </data>
  <data name="CategoryDebugging" xml:space="preserve">
    <value>디버깅</value>
  </data>
  <data name="CategoryPerformance" xml:space="preserve">
    <value>성능</value>
  </data>
  <data name="CategoryUpdates" xml:space="preserve">
    <value>업데이트</value>
  </data>
  <data name="ConfirmRemoval" xml:space="preserve">
    <value>정말로 이 설정을 삭제하시겠습니까?</value>
  </data>
  <data name="ErrorBotNameEmpty" xml:space="preserve">
    <value>봇 이름이 비었습니다!</value>
  </data>
  <data name="ErrorCantRemoveGlobalConfig" xml:space="preserve">
    <value>전역 설정을 지울 수 없습니다!</value>
  </data>
  <data name="ErrorCantRenameGlobalConfig" xml:space="preserve">
    <value>전역 설정의 이름을 변경할 수 없습니다!</value>
  </data>
  <data name="ErrorConfigDirectoryNotFound" xml:space="preserve">
    <value>설정 디렉토리를 찾을 수 없습니다!</value>
  </data>
  <data name="ErrorConfigPropertyInvalid" xml:space="preserve">
    <value>{0} 설정에 대한 속성 값이 잘못되었습니다: {1}</value>
    <comment>{0} will be replaced by name of the configuration property, {1} will be replaced by invalid value</comment>
  </data>
  <data name="ErrorInvalidCurrentCulture" xml:space="preserve">
    <value>CurrentCulture 값이 올바르지 않습니다. ConfigGenerator는 기본값으로 실행됩니다!</value>
  </data>
  <data name="ErrorNameAlreadyUsed" xml:space="preserve">
    <value>그 이름은 이미 사용 중입니다!</value>
    <comment>This happens e.g. when user wants to create a bot with name that exists already</comment>
  </data>
  <data name="ErrorNameReserved" xml:space="preserve">
    <value>이 이름은 사용할 수 없습니다!</value>
    <comment>This happens e.g. when user wants to create a bot with reserved name, such as "ASF"</comment>
  </data>
  <data name="ErrorObjectIsNull" xml:space="preserve">
    <value>{0} 값이 없습니다!</value>
    <comment>{0} will be replaced by object's name</comment>
  </data>
  <data name="ErrorVersionMismatch" xml:space="preserve">
    <value>ASF 버전에 맞지 않는 ConfigGenerator 사용을 시도했습니다!

ASF: {0} | ConfigGenerator: {1}

ASF 버전에 맞는 ConfigGenerator를 사용해주십시오. 적절한 릴리즈로 리디렉션 됩니다.</value>
    <comment>{0} will be replaced by ASF version (string), {1} will be replaced by ConfigGenerator version (string). Please note that this string should include newlines for formatting.</comment>
  </data>
  <data name="New" xml:space="preserve">
    <value>새로 만들기</value>
    <comment>This is used as MessageBox title</comment>
  </data>
  <data name="Removal" xml:space="preserve">
    <value>제거</value>
    <comment>This is used as MessageBox title</comment>
  </data>
  <data name="Rename" xml:space="preserve">
    <value>이름바꾸기</value>
    <comment>This is used as MessageBox title</comment>
  </data>
  <data name="TutorialBotFormEnabled" xml:space="preserve">
    <value>잘 하셨습니다! 이제 봇 인스턴스가 활성화되었습니다. 사실, 이것만으로도 ASF에서 해당 봇 사용이 가능하지만, 적어도 2개 이상의 다음 설정을 더 구성하는 것이 좋습니다: {0} 과 {1}. 만약 튜토리얼을 계속하길 원한다면, 계속하시길 바랍니다. 속성값을 설정하는 방법이나 추가적인 도움말이 필요하다면, 위키를 참고하는 것을 잊지 마십시오.</value>
    <comment>{0} will be replaced by "SteamLogin" configuration property, {1} will be replaced by "SteamPassword" configuration property</comment>
  </data>
  <data name="TutorialBotFormReady" xml:space="preserve">
    <value>ASF가 준비되었습니다! 단순하게 ASF.exe 를 실행하세요. 모든 것이 제대로 입력되었다면, ASF가 로그인하고 농사를 시작하는 것을 볼 수 있습니다. 만약 SteamGuard나 2단계 인증이 활성화되어 있다면, ASF는 실행되는 도중에 이러한 자격 증명을 물을 수 있습니다.</value>
  </data>
  <data name="TutorialFinished" xml:space="preserve">
    <value>축하합니다! ASF를 구동하기 위해 해야하는 모든 것과 준비된 튜토리얼을 완료했습니다. 이제, 오프라인 농사 또는 계정에 맞는 효율적인 농사 알고리즘 등 ASF가 제공하는 깔끔한 기능들을 설정하기 위해서 위키의 설정 관련 페이지를 모두 읽어보는 것을 강력히 권합니다. 이 모든 것은 선택 사항이니, 원하지 않는다면 지금 설정 창을 닫으셔도 됩니다. 여러분을 위해 만든 소프트웨어를 즐겨주셨으면 좋겠습니다!</value>
  </data>
  <data name="TutorialMainFormBotsManagementButtons" xml:space="preserve">
    <value>창 상단에 현재 불러온 설정과 제거하기[-], 이름 바꾸기[~], 새로 만들기[+] 3개의 추가 버튼을 확인할 수 있습니다.</value>
    <comment>If possible, try to keep visual representation of buttons: [-], [~] and [+]</comment>
  </data>
  <data name="TutorialMainFormConfigurationWiki" xml:space="preserve">
    <value>각 속성에 대한 설명, 목적, 사용 가능한 설정 값을 포함한 설정에 대한 모든 정보는 GitHub 위키에 있습니다. 참고로 사용해 주세요.</value>
  </data>
  <data name="TutorialMainFormConfigurationWindow" xml:space="preserve">
    <value>창 중앙에 현재 설정된 값과 설정할 수 있는 모든 속성이 표시 됩니다.</value>
  </data>
  <data name="TutorialMainFormFinished" xml:space="preserve">
    <value>이제 ASF의 설정을 시작해봅시다. [+] 버튼을 클릭해서 첫 번째 Steam 계정을 추가하십시오!</value>
    <comment>If possible, try to keep visual representation of [+] button</comment>
  </data>
  <data name="TutorialMainFormHelpButton" xml:space="preserve">
    <value>우측 상단에 상세한 정보를 위해 ASF 위키로 이동하는 [?] 버튼을 찾을 수 있습니다.</value>
    <comment>If possible, try to keep visual representation of [?] button</comment>
  </data>
  <data name="TutorialMainFormShown" xml:space="preserve">
    <value>이것이 ASF ConfigGenerator 메인 화면입니다. 정말 사용하기 쉽습니다!</value>
  </data>
  <data name="TutorialNewBotFormFinished" xml:space="preserve">
    <value>보시다시피, 여러분의 봇은 이제 설정될 준비가 되었습니다! 첫째로 해야 할 일은 {0} 속성을 false에서 true로 바꾸는 일입니다. 한번 해보세요!</value>
    <comment>{0} will be replaced by name of the configuration property ("Enabled")</comment>
  </data>
  <data name="TutorialNewBotFormShown" xml:space="preserve">
    <value>잘하셨습니다! 이제 여러분의 봇 이름을 물어볼 겁니다. 봇으로 사용하려고 하는 Steam 계정의 이름이 좋은 예로 볼 수 있습니다. 또는 봇 인스턴스에 쉽게 접속하기 위해 다른 이름을 사용하셔도 됩니다.</value>
  </data>
  <data name="TutorialStart" xml:space="preserve">
    <value>환영합니다! ASF ConfigGenerator를 처음 실행하셨습니다. 제가 조금 도와드리겠습니다.</value>
  </data>
  <data name="UserInputBotName" xml:space="preserve">
    <value>새로운 봇의 이름을 입력하세요: </value>
    <comment>Please note that this translation should end with space</comment>
  </data>
  <data name="WarningConfigPropertyModified" xml:space="preserve">
    <value>{0}의 값이 다음과 같이 설정되었습니다: {1}</value>
    <comment>{0} will be replaced by name of the configuration property, {1} will be replaced by new value</comment>
  </data>
</root>
